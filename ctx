#!/bin/bash
#
# A script to recursively find, filter, and concatenate file content
# from a target directory to the system clipboard or stdout.
#

# --- Variables & Initial Setup ---
declare -a IGNORE_DIRS=()
declare -a IGNORE_PATTERNS=()
declare -a POSITIONAL_ARGS=()
STDOUT_MODE=false #<-- New variable to track output mode

# --- Functions ---
usage() {
    echo "Usage: $0 [OPTIONS] <directory> <ext1> [ext2]..."
    echo "  Gathers content from a directory and copies it to the system clipboard or prints to stdout."
    echo
    echo "Arguments:"
    echo "  <directory>       The target directory to scan."
    echo "  <ext1> [ext2]...  One or more file extensions to include."
    echo
    echo "Options:"
    echo "  -i <dir>          Directory to ignore (e.g., -i .git -i node_modules)."
    echo "  -p <pattern>      Filename pattern to ignore (e.g., -p '*_test.lua')."
    echo "  -s, --stdout      Print to stdout instead of clipboard. Hides progress messages."
    echo "  -h, --help        Show this help message."
    echo
    echo "Examples:"
    echo "  $0 . lua                  # Gathers all .lua files and copies to clipboard."
    echo "  $0 . py -s | wc -l        # Prints all .py files to stdout and counts the lines."
    exit 1
}

# Determines the correct clipboard command based on the OS.
get_clipboard_cmd() {
    case "$(uname -s)" in
        Darwin) echo 'pbcopy' ;;
        Linux)
            if command -v wl-copy &> /dev/null; then
                echo 'wl-copy'
            elif command -v xclip &> /dev/null; then
                echo 'xclip -selection clipboard'
            else
                echo ""
            fi
            ;;
        *) echo "" ;;
    esac
}

# --- Manual Argument Parsing Loop ---
while [[ $# -gt 0 ]]; do
    case "$1" in
        -i)
            if [ -z "$2" ]; then echo "Error: Flag '-i' requires a directory argument." >&2; usage; fi
            IGNORE_DIRS+=("$2")
            shift 2
            ;;
        -p)
            if [ -z "$2" ]; then echo "Error: Flag '-p' requires a pattern argument." >&2; usage; fi
            IGNORE_PATTERNS+=("$2")
            shift 2
            ;;
        -s|--stdout) #<-- New option for stdout mode
            STDOUT_MODE=true
            shift 1
            ;;
        -h|--help)
            usage
            ;;
        -*)
            echo "Error: Unknown option '$1'" >&2
            usage
            ;;
        *)
            POSITIONAL_ARGS+=("$1")
            shift 1
            ;;
    esac
done

# --- Pre-flight Checks & Argument Validation ---
CLIPBOARD_CMD=""
if [ "$STDOUT_MODE" = false ]; then #<-- Only check for clipboard if not in stdout mode
    CLIPBOARD_CMD=$(get_clipboard_cmd)
    if [ -z "$CLIPBOARD_CMD" ]; then
        echo "Error: Clipboard utility not found for clipboard mode." >&2
        echo "Please install 'pbcopy' (macOS), 'wl-copy' (Wayland), or 'xclip' (X11)." >&2
        echo "Alternatively, use the -s / --stdout flag to pipe output." >&2
        exit 1
    fi
fi

if [ ${#POSITIONAL_ARGS[@]} -lt 2 ]; then
    echo "Error: Missing target directory or file extension." >&2
    usage
fi

TARGET_DIR="${POSITIONAL_ARGS[0]}"
if [ ! -d "$TARGET_DIR" ]; then
    echo "Error: Directory '$TARGET_DIR' not found." >&2
    exit 1
fi

EXTENSIONS=("${POSITIONAL_ARGS[@]:1}")

# --- Main Logic ---
cd "$TARGET_DIR" || exit 1

declare -a find_args=(".")
declare -a prune_conditions=()

for dir in "${IGNORE_DIRS[@]}"; do
    prune_conditions+=(-o -path "./${dir}")
done
for pattern in "${IGNORE_PATTERNS[@]}"; do
    prune_conditions+=(-o -name "${pattern}")
done

if [ ${#prune_conditions[@]} -gt 0 ]; then
    find_args+=(\( "${prune_conditions[@]:1}" \))
    find_args+=(-prune -o)
fi

find_args+=(\()
for i in "${!EXTENSIONS[@]}"; do
    find_args+=(-name "*.${EXTENSIONS[i]}")
    if [ "$i" -lt $((${#EXTENSIONS[@]} - 1)) ]; then
        find_args+=(-o)
    fi
done
find_args+=(\))
find_args+=(-type f -print0)

# --- File Processing ---
TEMP_OUTPUT=$(mktemp)
trap 'rm -f "$TEMP_OUTPUT"' EXIT

#<-- Conditionally redirect progress messages to stderr if in stdout mode
LOG_DEVICE="/dev/stdout"
if [ "$STDOUT_MODE" = true ]; then
    LOG_DEVICE="/dev/stderr"
fi

echo "Gathering context from '${TARGET_DIR}'..." > "$LOG_DEVICE"

FILES_FOUND=0
while IFS= read -r -d $'\0' filepath; do
    ((FILES_FOUND++))
    echo " -> Adding: ${filepath}" > "$LOG_DEVICE"
    {
        echo "--- FILE: ${filepath} ---"
        cat "${filepath}"
        echo
    } >> "$TEMP_OUTPUT"
done < <(find "${find_args[@]}")

# --- Final Output ---
if [ "$FILES_FOUND" -eq 0 ]; then
    echo "Warning: No matching files were found. Nothing has been changed or printed." >&2
    exit 0
fi

#<-- Final output logic based on the mode
if [ "$STDOUT_MODE" = true ]; then
    cat "$TEMP_OUTPUT"
else
    cat "$TEMP_OUTPUT" | $CLIPBOARD_CMD
    echo "-----------------------------------------------------"
    echo "Success! Copied content of ${FILES_FOUND} files to the clipboard."
fi
