#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.8"
# dependencies = [
#     "openai",
#     "rich",
#     "pyperclip",
#     "arabic_reshaper",
#     "python-bidi",
#     "ddgs",
#     "typer[all]",
# ]
# ///

import sys
import json
import os
import subprocess
import datetime
from typing import Optional, List, Dict, Any
from pathlib import Path
from collections import defaultdict

import openai
import pyperclip
import typer
from typing_extensions import Annotated
from rich.console import Console
from rich.live import Live
from rich.markdown import Markdown
from rich.spinner import Spinner

import arabic_reshaper
from bidi.algorithm import get_display
from ddgs import DDGS

# --- Constants ---
DEFAULT_LOCAL_API_URL = "http://localhost:1234/v1"
DEFAULT_SYSTEM_PROMPT = "You are a helpful assistant inside a terminal. Keep your responses short and concise."

# --- Tool Definition ---
search_tool_definition = {
    "type": "function",
    "function": {
        "name": "web_search",
        "description": "Performs a web search using DuckDuckGo to get up-to-date information or context about recent events, or specific facts.",
        "parameters": {
            "type": "object",
            "properties": {
                "query": {
                    "type": "string",
                    "description": "The search query to send to the search engine.",
                }
            },
            "required": ["query"],
        },
    },
}


# --- Configuration Management ---
class ConfigManager:
    """Handles loading of the configuration file."""

    def __init__(self, config_path: Path):
        self.config_file = config_path / "config.json"
        self.config = {}
        self.load()

    def load(self):
        """Loads config from file, or creates a default config."""
        try:
            if self.config_file.is_file():
                self.config = json.loads(self.config_file.read_text())
            else:
                self.config = {
                    "model": "local-model",
                    "api_url": DEFAULT_LOCAL_API_URL,
                    "api_key_var": "sk-dummy",
                }
                self.save()
        except (json.JSONDecodeError, IOError) as e:
            Console().print(
                f"[bold yellow]Warning:[/bold yellow] Could not load config file: {e}. Using defaults."
            )
            self.config = {
                "model": "local-model",
                "api_url": DEFAULT_LOCAL_API_URL,
                "api_key_var": "sk-dummy",
            }

    def save(self):
        """Saves the current configuration to the file."""
        self.config_file.parent.mkdir(parents=True, exist_ok=True)
        self.config_file.write_text(json.dumps(self.config, indent=2))

    def get(self, key: str, default: Any = None) -> Any:
        return self.config.get(key, default)


def get_config_path() -> Path:
    """Gets the base configuration directory respecting XDG standards."""
    xdg_config_home = os.getenv("XDG_CONFIG_HOME")
    if xdg_config_home:
        return Path(xdg_config_home) / "lm"
    return Path.home() / ".config" / "lm"


# --- Core Functions ---
def fix_rtl_output(text: str) -> str:
    """Correctly shapes and reorders RTL text for terminal display."""
    reshaped_text = arabic_reshaper.reshape(text)
    bidi_text = get_display(reshaped_text)
    return bidi_text


def perform_web_search(query: str, num_results: int = 10) -> str:
    """Performs a web search using DuckDuckGo and returns formatted results."""
    try:
        results = DDGS().text(query, max_results=num_results)
        if not results:
            return "No results found for the query."
        formatted_results = [
            f"**Source {i + 1}: {r['title']}**\nSnippet: {r['body']}\nURL: {r['href']}"
            for i, r in enumerate(results)
        ]
        return "\n\n---\n\n".join(formatted_results)
    except Exception as e:
        return f"An error occurred during web search: {e}"


# --- Agent and Context Functions ---
def edit_agent_profile(console: Console, agent_name: str):
    config_dir = get_config_path()
    agent_dir = config_dir
    agent_dir.mkdir(parents=True, exist_ok=True)
    prompt_path = agent_dir / f"{agent_name}.md"
    editor = os.getenv("EDITOR", "nano")
    console.print(
        f"Opening agent '[cyan]{agent_name}[/cyan]' with [yellow]{editor}[/yellow]..."
    )
    console.print(f"File path: [dim]{prompt_path}[/dim]")
    try:
        subprocess.run([editor, str(prompt_path)], check=True)
    except (FileNotFoundError, subprocess.CalledProcessError) as e:
        console.print(f"[bold red]Error:[/bold red] {e}")
        raise typer.Exit(code=1)


def load_system_prompt(console: Console, agent_name: Optional[str]) -> str:
    if not agent_name:
        return DEFAULT_SYSTEM_PROMPT
    config_dir = get_config_path()
    prompt_path = config_dir / f"{agent_name}.md"
    if not prompt_path.is_file():
        console.print(
            f"[bold red]Error:[/bold red] Agent not found at '[yellow]{prompt_path}[/yellow]'"
        )
        raise typer.Exit(code=1)
    try:
        system_prompt = prompt_path.read_text(encoding="utf-8")
        today = datetime.date.today()
        return f"{system_prompt}\n\n**Today's date:** {today}"
    except IOError as e:
        console.print(
            f"[bold red]Error reading agent profile '{prompt_path}':[/bold red] {e}"
        )
        raise typer.Exit(code=1)


def get_input(prompt_arg: Optional[str]) -> str:
    if prompt_arg:
        return prompt_arg
    if not sys.stdin.isatty():
        return sys.stdin.read().strip()
    return ""


def build_context(
    console: Console, from_clipboard: bool, files: Optional[List[str]]
) -> str:
    context_parts = []
    if from_clipboard:
        try:
            clipboard_content = pyperclip.paste()
            if clipboard_content:
                context_parts.append(
                    f"--- Content from clipboard ---\n{clipboard_content}"
                )
        except pyperclip.PyperclipException as e:
            console.print(f"[bold red]Clipboard error:[/bold red] {e}", file=sys.stderr)
    if files:
        for file_path in files:
            try:
                with open(file_path, "r", encoding="utf-8") as f:
                    context_parts.append(
                        f"--- Content from file: {file_path} ---\n{f.read()}"
                    )
            except (IOError, FileNotFoundError) as e:
                console.print(
                    f"[bold red]Error reading file '{file_path}':[/bold red] {e}",
                    file=sys.stderr,
                )
                raise typer.Exit(code=1)
    return "\n\n".join(context_parts)


# --- Main Execution Logic ---
app = typer.Typer(
    add_completion=False,
    help="A command-line chatbot that uses agent profiles, files, and the clipboard as context.",
    no_args_is_help=True,
)


@app.callback(invoke_without_command=True)
def main(
    # --- Prompt and Context Arguments ---
    prompt: Annotated[
        Optional[str],
        typer.Argument(help="The user prompt. Reads from stdin if not provided."),
    ] = None,
    file: Annotated[
        Optional[List[str]],
        typer.Option(
            "-f",
            "--file",
            help="Path to a file to add to the context. Can be used multiple times.",
        ),
    ] = None,
    from_clipboard: Annotated[
        bool,
        typer.Option(
            "-c",
            "--from-clipboard",
            help="Add the content of the clipboard to the context.",
        ),
    ] = False,
    # --- Agent and Configuration Arguments ---
    agent: Annotated[
        Optional[str],
        typer.Option("-a", "--agent", help="Name of the agent profile to load."),
    ] = None,
    edit_agent: Annotated[
        Optional[str],
        typer.Option(
            "-e",
            "--edit-agent",
            metavar="AGENT_NAME",
            help="Create or edit an agent profile.",
        ),
    ] = None,
    # --- Model and API Arguments (overrides config) ---
    model: Annotated[
        Optional[str],
        typer.Option(
            "-m", "--model", help="Override the configured model for this request."
        ),
    ] = None,
    api_url: Annotated[
        Optional[str],
        typer.Option(
            "-u", "--api-url", help="Override the configured API endpoint URL."
        ),
    ] = None,
    # --- API Parameters ---
    use_search: Annotated[
        bool,
        typer.Option(
            "-s", "--use-search", help="Enable the web search tool for the agent."
        ),
    ] = False,
    temperature: Annotated[
        float, typer.Option("-t", "--temperature", help="The sampling temperature.")
    ] = 0.2,
    top_p: Annotated[
        float, typer.Option("-p", "--top-p", help="The nucleus sampling probability.")
    ] = 0.95,
):
    console = Console()

    # Handle the agent editing mode
    if edit_agent:
        edit_agent_profile(console, edit_agent)
        raise typer.Exit()

    config_manager = ConfigManager(get_config_path())

    try:
        # --- Configure API Client ---
        base_url = api_url or config_manager.get("api_url")
        api_model = model or config_manager.get("model")
        api_key_var = config_manager.get("api_key_var", "sk-dummy")

        api_key = "sk-dummy"
        if api_key_var and api_key_var != "sk-dummy":
            api_key = os.getenv(api_key_var)
            if not api_key:
                console.print(
                    f"[bold red]Error:[/bold red] The environment variable '{api_key_var}' is specified in your config but is not set."
                )
                raise typer.Exit(code=1)

        client = openai.OpenAI(base_url=base_url, api_key=api_key)

        # --- Build prompt and messages ---
        system_prompt = load_system_prompt(console, agent)
        context_str = build_context(console, from_clipboard, file)
        user_prompt = get_input(prompt)
        final_user_message = (
            f"{context_str}\n\n---\n\n{user_prompt}" if context_str else user_prompt
        )

        if not final_user_message:
            console.print(
                "[bold red]Error:[/bold red] Prompt is empty. Provide a prompt as an argument or pipe it via stdin.",
                file=sys.stderr,
            )
            raise typer.Exit(code=1)

        messages = [
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": final_user_message},
        ]
        tools = [search_tool_definition] if use_search else None

        # --- Main Tool-Use Loop ---
        for _ in range(2):  # Allows one tool call turn
            api_kwargs = {
                "model": api_model,
                "messages": messages,
                "temperature": temperature,
                "top_p": top_p,
                "stream": True,
            }
            if tools:
                api_kwargs["tools"] = tools
                api_kwargs["tool_choice"] = "auto"

            spinner_text = f"[grey]{api_model}[/grey]..."
            with Live(
                Spinner("dots", text=spinner_text),
                console=console,
                auto_refresh=True,
                transient=True,
            ) as live:
                stream = client.chat.completions.create(**api_kwargs)

                full_delta = defaultdict(str)
                tool_calls = []
                for chunk in stream:
                    delta = chunk.choices[0].delta
                    full_delta["content"] += delta.content or ""

                    if delta.tool_calls:
                        for tool_call_chunk in delta.tool_calls:
                            if len(tool_calls) <= tool_call_chunk.index:
                                tool_calls.append(defaultdict(str))

                            call = tool_calls[tool_call_chunk.index]
                            call["id"] += tool_call_chunk.id or ""
                            call["function_name"] += tool_call_chunk.function.name or ""
                            call["function_args"] += (
                                tool_call_chunk.function.arguments or ""
                            )

                    if not tool_calls:
                        live.update(
                            Markdown(fix_rtl_output(full_delta["content"])),
                            refresh=True,
                        )

            assistant_message = {"role": "assistant"}
            if full_delta["content"]:
                assistant_message["content"] = full_delta["content"]

            if tool_calls:
                console.print("[dim]Tool call requested by model...[/dim]")
                assistant_message["tool_calls"] = []
                for tc in tool_calls:
                    assistant_message["tool_calls"].append(
                        {
                            "id": tc["id"],
                            "type": "function",
                            "function": {
                                "name": tc["function_name"],
                                "arguments": tc["function_args"],
                            },
                        }
                    )
                messages.append(assistant_message)

                for tool_call in assistant_message["tool_calls"]:
                    function_name = tool_call["function"]["name"]
                    if function_name == "web_search":
                        try:
                            args_dict = json.loads(tool_call["function"]["arguments"])
                            query = args_dict.get("query")
                            console.print(
                                f"[dim]Performing web search for: [cyan]{query}[/cyan][/dim]"
                            )
                            tool_output = perform_web_search(query)
                            messages.append(
                                {
                                    "role": "tool",
                                    "tool_call_id": tool_call["id"],
                                    "content": tool_output,
                                }
                            )
                        except json.JSONDecodeError:
                            console.print(
                                "[bold red]Error decoding tool arguments.[/bold red]"
                            )
                            messages.append(
                                {
                                    "role": "tool",
                                    "tool_call_id": tool_call["id"],
                                    "content": "Error: Invalid JSON in arguments.",
                                }
                            )

                tools = None
                continue

            console.print(Markdown(fix_rtl_output(full_delta["content"])))
            break

    except KeyboardInterrupt:
        console.print("\n[yellow]Operation cancelled by user.[/yellow]")
        raise typer.Exit(code=130)
    except openai.APIError as e:
        console.print(f"[bold red]API Error:[/bold red] {e}")
        raise typer.Exit(code=1)


if __name__ == "__main__":
    app()
